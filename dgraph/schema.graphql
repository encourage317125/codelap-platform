type User {
  id: ID!
  # Indexing with Custom Tokenizer
  email: String! @id @search(by: [hash])
  # user_id: String! @id
  apps: [App!]
  libraries: [Library!]
}
type App
  @auth(
    query: {
      rule: """
      query($USER: String!) {
        queryApp {
          owner(filter: { email: { eq: $USER }}) {
            __typename
          }
        }
      }
      """
    }
    # Only allows node to be created given this condition, meaning we'll have to have owner link set
    add: {
      rule: """
      query ($USER: String!) {
        queryApp {
          owner(filter: { email: { eq: $USER } } ) {
            email
          }
        }
      }
      """
    }
  ) {
  id: ID!
  owner: User! @hasInverse(field: "apps")
  # id: String! @id
  name: String!
}

type Library {
  id: ID!
  # id: String! @id
  name: String!
  atoms: [Atom] @hasInverse(field: "library")
  components: [Component] @hasInverse(field: "library")
}

type Component {
  id: ID!
  label: String!
  children: [Component]
  atom: Atom
  library: Library!
  tags: [Tag]
  #TODO add props and prop types to Component (and slots?)
}

type Atom {
  id: ID!
  type: String!
  library: Library
  label: String!
}

type Tag {
  label: String!
}


type GetAllUsersPayload {
  id: ID!
  email: String
}


type Query {
  GetAllUsers: [GetAllUsersPayload]
    @custom(
      dql: """
      query {
        GetAllUsers(func: type(User)) {
          dgraph.type
          email: User.email
          id: uid
        }
      }
      """
    )
  userWhere(email: String!): User
    @custom(
      dql: """
      query user($email: string) {
        q(func: eq(User.email, $email)){
          email
          dgraph.type
          id: uid
        }
      }
      """
    )
  # query user {
  #      q(func: type(User)) @filter(eq(email, "webber@codelab.ai")) {
  #        dgraph.type
  #        id: uid
  #      }
  #    }
}

input UpsertUserInput {
  email: String!
}

# type Mutation {
#   upsertUser(input: UpsertUserInput!): User
#     @custom(
#       dql: """
#       query {
#         v asq(func: eq(User.email: input.email)) {
#           v as uid
#           email
#         }
#       }
#       mutation @if(gt(len(v), 0)) {
#         _.user <email> input.email .
#         _.user <dgraph.type> "User .
#       }
#       """
#     )
# }


# Dgraph.Authorization {  "VerificationKey":"-----BEGIN PUBLIC KEY-----\nMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAn1Js+QgC/8cczuWCAoP3\n1bnUaFuUjwNW9x96/diDHrbNf75ft74ZayJjqPjc53CrpU42N7ppdfInB6DNRdvz\no/7Ihvio2WmDaGlbCaDWEApLWAfpT2s5vSqVAylXTsIe050nLW5SwTR4n8gUgEAZ\noJu3pFNjheY1PQO2O4KKOl/IfcJ5M7AfKpbbTbaJ2p+9LbAkTMkOu1cT1735705D\n7glaerTKM1HQUzqlIFdK0yNjvg8jitEsAr/HMhgR93X6Scj+zqjET02uAF4Ea86G\n5DpWl3sETkqU9Egvd6VmqOVennVMcbOnYZowYlNWxHaK8H9LiiZyIFmcFeoWiFvy\nGwIDAQAB\n-----END PUBLIC KEY-----","Header":"X-Auth-Token","Namespace":"https://dgraph.io/jwt/claims","Algo":"RS256","Audience":["nNN1GfrDp2S4Uj7yK5kxEcKjo1PFMwTI"]}
